package com.github.peckb1.topcoder.practice.medium;

/**
 * Our alarm system is intended to keep intruders from entering at the front door of a square room, crossing the room,
 * and then exiting through the back door. It consists of noise sensors located at various points on the floor of the
 * room. Each sensor has its own threshold sound level -- it will warn us if the sound level at the sensor exceeeds
 * its threshold.
 * The sound generated by an intruder attenuates according to an inverse square law. Specifically, at a distance r
 * from an intruder, the sound level will be A/r2, where A is the noisiness of the intruder.
 * <p>
 * The room is square, with each side of length 100.0. The coordinates of the southwest corner are (x=0,y=0) and
 * the coordinates of the northeast corner are (x=100,y=100). The intruder will enter at (50,0) and exit at (50,100).
 * <p>
 * Given s x, y, and threshold return the largest value of A that will allow an intruder to walk through the room
 * without setting off an alarm. The i-th sensor is described by the ith elements of x, y, and threshold. Note that
 * we cannot expect an intruder to limit his path to integer coordinates!
 * <p>
 * This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction
 * of this information without the prior written consent of TopCoder, Inc. is strictly prohibited.
 * (c)2003, TopCoder, Inc. All rights reserved.
 */
public class Alarmed {

    private static final double DELTA = 1e-9;
    private static final int ENTRANCE_X = 50;
    private static final int ENTRANCE_Y = 0;
    private static final int EXIT_X = 50;
    private static final int EXIT_Y = 100;

    private int sensors;
    private boolean[][] rels;
    private boolean[] left;
    private boolean[] rigt;
    private int[] x;
    private int[] y;
    private int[] thresholds;

    public double noise(int[] xx, int[] yy, int[] threshold) {
        this.x = xx;
        this.y = yy;
        this.thresholds = threshold;
        this.sensors = xx.length;
        this.rels = new boolean[sensors][sensors];
        this.left = new boolean[sensors];
        this.rigt = new boolean[sensors];

        double dMinA = 0;
        double dMaxA = Integer.MAX_VALUE;

        while (dMaxA - dMinA > DELTA) {
            double dMid = (dMinA + dMaxA) / 2;
            if (isQuietEnough(dMid)) {
                dMinA = dMid;
            } else {
                dMaxA = dMid;
            }
        }

        return (dMinA + dMaxA) / 2;
    }

    private static double distance(int x1, int y1, int x2, int y2) {
        return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
    }

    private boolean isQuietEnough(double noisiness) {
        for (int i = 0; i < sensors; i++) {
            for (int j = 0; j < sensors; j++) {
                rels[i][j] = false;
            }
        }

        for (int i = 0; i < sensors; i++) {
            left[i] = false;
            rigt[i] = false;
        }

        for (int sensor = 0; sensor < sensors; sensor++) {
            double distanceToExit = distance(x[sensor], y[sensor], EXIT_X, EXIT_Y);
            double distanceToEntrance = distance(x[sensor], y[sensor], ENTRANCE_X, ENTRANCE_Y);
            double soundRadius = Math.sqrt(noisiness / thresholds[sensor]);

            // if the sound of our noisiness hits either the entrance or the exit
            // we can't get in and out without setting off the alarm
            if (soundRadius >= distanceToExit || soundRadius >= distanceToEntrance) {
                return false;
            }

            // since we know we're in the middle of the path for entrance and exits
            // lets mark left[sensor] as if we would be found if we were on the left
            // side of sensor with our given radius
            if (soundRadius >= x[sensor]) {
                left[sensor] = true;
            } else if (x[sensor] <= 50) {
                if (soundRadius >= y[sensor] || soundRadius >= (100 - y[sensor])) {
                    left[sensor] = true;
                }
            }

            // since we know we're in the middle of the path for entrance and exits
            // lets mark right[sensor] as if we would be found if we were on the right
            // side of sensor with our given radius
            if (soundRadius >= 100 - x[sensor]) {
                rigt[sensor] = true;
            } else if (x[sensor] >= 50) {
                if (soundRadius >= y[sensor] || soundRadius >= (100 - y[sensor])) {
                    rigt[sensor] = true;
                }
            }
        }

        // we have distinct values for the left and right of each sensor
        // but we also need to know if we woudl be caught between two sensors
        // so mark rels[sensorA][sensorB] to be true if the nosiness of each
        // sensor would touch and find us.
        for (int i = 0; i < sensors; i++) {
            for (int j = i + 1; j < sensors; j++) {
                double dist = distance(x[i], y[i], x[j], y[j]);

                double r1 = Math.sqrt(noisiness / thresholds[i]);
                double r2 = Math.sqrt(noisiness / thresholds[j]);
                if (r1 + r2 >= dist) {
                    rels[i][j] = true;
                    rels[j][i] = true;
                }
            }
        }

        // alter our `left` array to set the value to true
        // if we were unable to walk between two given nodes
        // if we could walk ok the left of it before, but
        // could not walk on the left of the other node we're
        // comparing ourself too
        while (true) {
            boolean found = false;
            for (int i = 0; i < sensors; i++) {
                if (left[i]) {
                    continue;
                }

                for (int j = 0; j < sensors; j++) {
                    if (rels[i][j] && left[j]) {
                        found = true;
                        left[i] = true;
                        break;
                    }
                }
            }
            if (!found) {
                break;
            }
        }

        // return that we're bad if we can't walk to the right and left of any sensor
        for (int i = 0; i < sensors; i++) {
            if (left[i] && rigt[i]) {
                return false;
            }
        }

        // otherwise we have not been cought - so return that this noisiness level is ok
        return true;
    }
}
